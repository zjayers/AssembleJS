name: deploy_next_version

on:
  push:
    branches:
      - next
    # Prevent build on workflow changes to avoid accidental releases
    paths-ignore:
      - '.github/workflows/**'
  
  # Manual trigger
  workflow_dispatch:

permissions:
  contents: read
  packages: write

# Define reusable cache key and outputs
env:
  cache-key: build-artifacts-${{ github.sha }}

jobs:
  # Primary build job that constructs all artifacts
  build:
    name: Build Next Version
    runs-on: ubuntu-latest
    outputs:
      package_tgz: ${{ steps.pack.outputs.package_tgz }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'
          cache: 'npm'
          registry-url: 'https://registry.npmjs.org'
      
      - name: Install dependencies
        run: npm ci --include=dev
        
      - name: Install website dependencies
        run: cd websites/www.assemblejs.com && npm ci
      
      - name: Build and pack main package
        id: pack
        run: |
          # Run npm pack and capture the filename
          PACKAGE_TGZ=$(npm pack | tail -n 1)
          echo "Generated package: $PACKAGE_TGZ"
          echo "package_tgz=$PACKAGE_TGZ" >> $GITHUB_OUTPUT
        
      - name: Install Testbed dependencies
        run: npm run testbed:install

      - name: Build testbed projects
        run: npm run testbed:build
      
      - name: Cache build artifacts
        uses: actions/cache/save@v4
        with:
          path: |
            lib/
            websites/www.assemblejs.com/build/
            testbed/*/dist/
            docs/
            *.tgz
          key: ${{ env.cache-key }}
          enableCrossOsArchive: true
  
  # Publish package to npm with next tag
  publish-package:
    name: Publish Package to NPM
    needs: build
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'
          cache: 'npm'
          registry-url: 'https://registry.npmjs.org'
      
      - name: Restore build artifacts
        uses: actions/cache/restore@v4
        with:
          path: |
            lib/
            websites/www.assemblejs.com/build/
            testbed/*/dist/
            docs/
            *.tgz
          key: ${{ env.cache-key }}
          fail-on-cache-miss: true
      
      - name: Publish to npm
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
        run: |
          echo "Publishing package: ${{ needs.build.outputs.package_tgz }}"
          npm publish "${{ needs.build.outputs.package_tgz }}" --tag next
          echo "Published package to npm with tag: next"
  
  # Deploy website to S3 next bucket
  deploy-website:
    name: Deploy Next Website
    needs: [build, publish-package]
    runs-on: ubuntu-latest
    environment: staging
    permissions:
      contents: read
      id-token: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'
      
      - name: Restore build artifacts
        uses: actions/cache/restore@v4
        with:
          path: |
            lib/
            websites/www.assemblejs.com/build/
            testbed/*/dist/
            docs/
            *.tgz
          key: ${{ env.cache-key }}
          fail-on-cache-miss: true
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ vars.AWS_REGION || 'us-east-1' }}
          role-session-name: GithubActionsSession
          role-duration-seconds: 900
      
      - name: Deploy to S3 next bucket
        run: |
          S3_BUCKET="www.next.assemblejs.com"
          aws s3 sync "websites/www.assemblejs.com/build/" "s3://$S3_BUCKET/" --delete
          echo "üöÄ AssembleJS next website successfully deployed to www.next.assemblejs.com"
  
  # Package and upload testbed projects as container images
  deploy-testbed:
    name: Deploy Testbed Projects
    needs: [build, publish-package]
    runs-on: ubuntu-latest
    environment: staging
    permissions:
      contents: read
      id-token: write
      packages: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'
      
      - name: Restore build artifacts
        uses: actions/cache/restore@v4
        with:
          path: |
            lib/
            websites/www.assemblejs.com/build/
            testbed/*/dist/
            docs/
            *.tgz
          key: ${{ env.cache-key }}
          fail-on-cache-miss: true
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ vars.AWS_REGION || 'us-east-1' }}
          role-session-name: GithubActionsSession
          role-duration-seconds: 900
      
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Create package and deploy artifacts
        run: |
          ECR_REGISTRY="${{ steps.login-ecr.outputs.registry }}"
          ECR_REPOSITORY_BASE="assemblejs-testbed"
          TIMESTAMP=$(date +%Y%m%d%H%M%S)
          
          # Create a list of projects with dist directories for parallel processing
          cd testbed
          PROJECTS_TO_BUILD=()
          for project_dir in assemblejs-*/; do
            project_name="${project_dir%/}"
            if [ -d "$project_dir/dist" ]; then
              PROJECTS_TO_BUILD+=("$project_name")
              
              # Set up Dockerfile in advance
              if [ -f "Dockerfile.testbed" ]; then
                cp "Dockerfile.testbed" "$project_name/Dockerfile"
              else
                echo "::error::Shared Dockerfile template not found at Dockerfile.testbed"
                exit 1
              fi
              
              # Create ECR repository if it doesn't exist (all in parallel)
              echo "Checking/creating ECR repository: $ECR_REPOSITORY_BASE/$project_name"
              aws ecr describe-repositories --repository-names "$ECR_REPOSITORY_BASE/$project_name" > /dev/null 2>&1 || \
                aws ecr create-repository --repository-name "$ECR_REPOSITORY_BASE/$project_name" > /dev/null 2>&1 &
            else
              echo "‚ö†Ô∏è No dist directory found for $project_name, skipping"
            fi
          done
          
          # Wait for all repository creation tasks to complete
          wait
          
          # Use buildx for parallel builds with caching
          echo "Found ${#PROJECTS_TO_BUILD[@]} projects to build and deploy"
          
          # Start all builds in parallel with buildx
          for project_name in "${PROJECTS_TO_BUILD[@]}"; do
            echo "---------------------------------------------"
            echo "üì¶ Packaging $project_name for deployment"
            
            IMAGE_TAG="$ECR_REGISTRY/$ECR_REPOSITORY_BASE/$project_name:next-$TIMESTAMP"
            IMAGE_TAG_LATEST="$ECR_REGISTRY/$ECR_REPOSITORY_BASE/$project_name:next-latest"
            
            # Use buildx with parallel processing and caching
            echo "üî® Building and pushing Docker image for $project_name"
            docker buildx build \
              --platform linux/amd64 \
              --cache-from type=registry,ref="$IMAGE_TAG_LATEST" \
              --cache-to type=inline \
              --push \
              -t "$IMAGE_TAG" \
              -t "$IMAGE_TAG_LATEST" \
              -f "$project_name/Dockerfile" \
              "$project_name" &
            
            # Limit parallel jobs to avoid overwhelming the runner
            # Wait if we have 3 or more jobs running
            JOBS_RUNNING=$(jobs -p | wc -l)
            if [ $JOBS_RUNNING -ge 3 ]; then
              echo "Waiting for a build job to finish before starting more..."
              wait -n
            fi
          done
          
          # Wait for all remaining builds to complete
          echo "Waiting for all remaining builds to complete..."
          wait
          
          echo "üöÄ All testbed projects successfully built and pushed to ECR in parallel"

  # Deploy ARLO to ECR
  deploy-arlo:
    name: Deploy ARLO
    needs: [build, publish-package]
    runs-on: ubuntu-latest
    environment: staging
    permissions:
      contents: read
      id-token: write
      packages: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'
      
      - name: Install ARLO dependencies
        run: |
          cd .arlo
          npm ci --production
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ vars.AWS_REGION || 'us-east-1' }}
          role-session-name: GithubActionsSession
          role-duration-seconds: 900
      
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Deploy ARLO to ECR
        run: |
          ECR_REGISTRY="${{ steps.login-ecr.outputs.registry }}"
          ECR_REPOSITORY="assemblejs-arlo"
          TIMESTAMP=$(date +%Y%m%d%H%M%S)
          
          # Create ECR repository if it doesn't exist
          echo "Checking/creating ECR repository: $ECR_REPOSITORY"
          aws ecr describe-repositories --repository-names "$ECR_REPOSITORY" > /dev/null 2>&1 || \
            aws ecr create-repository --repository-name "$ECR_REPOSITORY" > /dev/null 2>&1
          
          # Build image tags
          IMAGE_TAG="$ECR_REGISTRY/$ECR_REPOSITORY:next-$TIMESTAMP"
          IMAGE_TAG_LATEST="$ECR_REGISTRY/$ECR_REPOSITORY:next-latest"
          
          echo "üì¶ Packaging ARLO for deployment"
          
          # Build and push Docker image
          echo "üî® Building and pushing Docker image for ARLO"
          docker buildx build \
            --platform linux/amd64 \
            --cache-from type=registry,ref="$IMAGE_TAG_LATEST" \
            --cache-to type=inline \
            --push \
            -t "$IMAGE_TAG" \
            -t "$IMAGE_TAG_LATEST" \
            -f ".arlo/Dockerfile" \
            ".arlo"
          
          echo "üöÄ ARLO successfully built and pushed to ECR: $IMAGE_TAG"

  # Create GitHub release for next version
  create-release:
    name: Create GitHub Release
    needs: [publish-package]
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4
      - name: Get Package Version
        id: package_version
        run: echo "version=$(node -p "require('./package.json').version")" >> $GITHUB_OUTPUT
      - name: Create Next Release
        uses: ncipollo/release-action@v1
        with:
          tag: v${{ steps.package_version.outputs.version }}-next
          name: "AssemblyJS v${{ steps.package_version.outputs.version }}-next (Preview)"
          prerelease: true
          generateReleaseNotes: true